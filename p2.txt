16.01-Sugar Macros
AÇÚCAR
======

O processo de construção de açúcar permite transformar uma sintaxe 
em outra:
            sintaxe A ----------------------> sintaxe B
                                               (core)

O primeiro exemplo que utilizamos para açúcar sintático foi:
        (let (var val) body) --> ((λ (var) body) val)

Mas assim como conseguimos criar regras de açúcar diretamente na 
linguagem açucarada, também poderíamos fazê-lo EM TEMPO DE INTERPRETAÇÃO
(on the fly).

No Racket, existe essa opção, por meio dos comando:
    (define-syntax macro regra)
                         ^^^^^- { syntax-rules
                                { syntax-case

Criaremos um "novo let". Para que o próprio Racket não se confunda, 
usaremos o nome "my-let" com números 1,2,... para eles.

(define-syntax my-let-1
    (syntax-rules () ; arg para definir associações locais às regras
        
        ; Lista de regras de tradução
        [(my-let-1 (var val) body) ((lambda (var) body) val)]
        
        ; Cada uma das regras trabalha como MACRO - nenhuma 
        ; modificação é criada e só se traduz de um para outro.
))

Podemos aceitar argumentos como listas de qualquer tamanho, usando
o símbolo "...". Ele funciona como os TEMPLATES VARIÁDICOS do C++ 
ou as funções com múltiplos argumentos do C:

                    ..----------------------------..-------------..
                    \/                            /\             /\
         Constroi 'n' pares (var val)       Pega 'n' vars  Pega 'n' vals
                _____________                 _________       ________
    [(my-let-2 [(var val) ...] body) ((lambda (var ...) body) val ...)]

O Dr. Racket tem a opção MACRO-STEPPER, que mostra qual o resultado das
EXPANSÕES DE MACROS criadas pelo define-syntax. Entretanto, nem sempre
o resultado pode ser o esperado, pois o Racket pode OTIMIZAR os
argumentos variádicos para seus próprios lambdas.

PROBLEMAS
-----------

Os macros são interessantes, mas podem gerar problemas parecidos com as
macros de C/C++: os erros não são checados quando definimos as novas
regras sintáticas. Por exemplo

* Racket                          | * C/C++
                                  | 
; Em vez de um símbolo para       | // Definição do Macro em C ou C++.
; argumento, colocamos um número  | // Não usamos paerênteses suficientes
(my-let-1 (1 5) 1)                | #define SQUARE(X) X*X
                                  | 
; A tradução ficaria:             | // A expressão:
((λ (1) 1) 5)                     | SQUARE(2+2);
                                  | 
; O erro, porém seria:            | // Seria traduzida em:
    lambda: not an identifier,    | 2+2*2+2
    identifier with default, or   | 
    keyword in: 1                 | // O resultado 8 é diferente de 16

SYNTAX-CASE
=============

Poderemos usar,agora, o SYNTAX-CASE, mais geral, para que façamos
regras válidas.

Ele receberá uma lista de pares [A, B], com:
* A, o padrão a ser identificado na linguagem;
* B, cujo VALOR INTERPRETADO será associado a A;

O fato dele associar o VALOR INTERPRETADO da expressão B pode ser 
ruim, caso queiramos apenas devolver uma expressão. Para isso, usaremos
um truque relacionado ao operador #' (à frente).

; Associamos o nome 'my-let-3' a um símbolo x. O 'x' é um auxiliar, 
; que permite chamar RECURSIVAMENTE a estrutura do define-syntax.
; Isso é importante porque o símbolo "my-let-3" poderia ser utilizado
; dentro do pattern ou valor. Temos, então, este auxiliar.
(define-syntax (my-let-3 x)
    
    ; O 'x' de acima é passado para o syntax-case, como um 'this'.
    (syntax-case x ()
        [
         ; Padrão a ser identificado
         (my-let-3 (var val) body) 
         
         ; O símbolo #' serve para que o syntax-case devolva a 
         ; própria expressão, e não o resultado da execução dela.
         ; Em geral, para não executarmos, usamos apenas '. Porém,
         ; ' transforma uma expressão em s-expression. O syntax-case
         ; EXIGE que o argumento seja um PEDAÇO DE SINTAXE - e o
         ; operador #' é o que evita a execução e devolve um peraço
         ; de sintaxe. O #' será necessário em todos os casos em que
         ; quisermos usar um pedaço do pattern, sem executá-lo (o que
         ; seria, inclusive, impossível, pois ele não existe ainda
         ; dentro da macro).
         #'((lambda (var) body) val)
        ]
))

O my-let-3 faz exatamente o mesmo que o my-let-2, mas usa o syntax-case.
Entretanto, o syntax-case tem uma segunda forma que pode ser útil.
Ele não receberá mais pares [A B], em que associa-se o padrão A 
ao valor (B). Teremos como argumentos trincas [A P B], com:
* A, o padrão;
* B, cujo valor interpretado será associado a A;
* P (predicado), as RESTRIÇõES a serem avaliadas.

(define-syntax (my-let-4 x)
    (syntax-case x ()
        [
         ; Padrão a ser identificado 
         (my-let-4 (var val) body) 
        
         ; Predicado a ser avaliado
         ; Se 'var' não for identificador, dará erro.
         (identifier? #'var)
         
         ; Igual ao caso do my-let-3
         #'((lambda (var) body) val)
        ]
))

SYNTAX-CASE RECURSIVO
=======================

Vejamos um exemplo de syntax-case RECURSIVO. Para isso, vamos
implementar uma forma de OR usando IF's recursivamente:

(define-syntax (my-or-1 x)
  (syntax-case x ()
    ; Usamos um template variádico
    [(my-or-1 e0 e1 ...)
      #'(if e0
            e0
            (my-or-1 e1 ...))
            ; Reusamos o template variádico com menos 1 argumento.
            ; Como a lista é finita, uma hora a recursão para.
))

Esse comando dá um erro, porque no final não teremos mais como expandir
o my-or-1. Consideremos o exemplo:
                            (my-or-1 #f #t)

O resultado da expansão seria:
(if #f #f (my-or-1 #t))
           ^^^^^^^-- (if #t #t (my-or-1))
                                ^^^^^^^-- Sem argumentos, é desconhecido

Precisamos adicionar uma nova regra ao syntax-case, para quando ele 
tem 0 argumentos.

(define-syntax (my-or-2 x)
  (syntax-case x ()
    [(my-or-2) 
      #'#f]
    [(my-or-2 e0 e1 ...)
      #'(if e0
            e0
            (my-or-2 e1 ...))
))

Poderíamos adicionar um passo a mais, com apenas um argumento. O
anterior já funciona, mas poderíamos adicionar um caso extra: apenas
um argumento, em que o devolvemos.

(define-syntax (my-or-3 x)
  (syntax-case x ()
    [(my-or-3) 
      #'#f]
    [(my-or-3 e0) 
      #'e0]
    [(my-or-3 e0 e1 ...)
      #'(if e0
            e0
            (my-or-3 e1 ...))
))

Nesse caso, naturalmente, nunca entraremos no caso base my-or-3 vazio.
Poderíamos retirá-lo, para dar erro de sintaxe, OU devolver falso nos
casos errados.

Considermeos agora o seguinte exemplo:
(let ([blah #f])
(my-or-3
    (begin ((set! blah (not blah)) blah)
    #f)
)

O resultado expandido será:
(if (begin ((set! blah (not blah)) blah))
    (begin ((set! blah (not blah)) blah))
    (my-or-4 #f))

O valor devolvido seria #f (errado!).

Estamos DUPLICANDO código. Esse é um dos grandes problemas de macros:
replicação desnecessária. E isso ocorre por causa do excesso de lazyness
do código.

Para resolvermos, podemos calcular primeiro, e associar o valor
calculado a um símbolo:

(define-syntax (my-or-4 x)
  (syntax-case x ()
    [(my-or-4) 
      #'#f]
    [(my-or-4 e0) 
      #'e0]
    [(my-or-4 e0 e1 ...)
      #(let ([v e0])
        '(if e0
             e0
             (my-or-4 e1 ...))
))

Ainda assim, temos dois potenciais problemas:
* O cálculo do primeiro e0 poderia causar uma mudança de estado - e esta
  não seria passada para o corpo do if. A mudança de estado já estaria
  feita antes, e o resultado poderia ser diferente. Uma outra
  consequência da passagem de estado. O caso do begin acima não era o
  desejado. Porém, se ele fosse, não seria coberto.

* O e0 poderia estar em um environment diferente, e o seu valor estaria
  de forma diferente. Por exemplo:
    
    (let ([e0 #t]) (my-or-4 #f e0))
    
    A expansão seria:
    (let ([v #f])
        if(#f) #f
            (my-or-4 #f))
    
    Nesse caso, estamos CONFUNDINDO o environment externo com o
    environment interno. O valor de e0 usado acaba sendo o de dentro,
    e não o passado de fora.
    
    Bons sistemas de macro não confundem isso, pois usam tabelas
    separadas para valores de argumentos e definições internas de
    símbolos. Essas são chamadas as MACROS HIGIÊNICAS.


17.01-More Macros
MACROS
========

Na aula passada, vimos uma "confusão" dos macros por causa do
environment. A diferenciação entre ambos pode ser desejável, para que
possamos fazer definições de macros RECURSIVAS ou com AUTORREFERÊNCIA.

Os macros que evitam esse problema é um MACRO HIGIÊNICO, mas teria esse 
novo problema. A implementação que daria este problema seria:

; Definição de um objeto com autorreferência
; usando a criação via macros.
(define os-1
    (object/self-1
        
        ; Este self dará um ERRO. O processador de macros do Racket
        ; é higiênico. Logo, dentro do macro ele olhará se esse self
        ; foi definido NESTE AMBIENTE. Ele não foi: logo, aparecerá o
        ; erro do self não ser definido.
        [first  (x) (msg self 'second (+ x 1))]
        
        [second (x) (+ x 1)]
))

; Como fazemos isso com macros agora?
(define-syntax object/self-1
  (syntax-rules ()
    [(object [mtd-name (var) val] ...)
        
      ; Primeiro, associamos self com um símbolo qualquer. 
      ; No caso, é um lambda que imprime que está vazio.
      (let ([self (lambda (msg-name)
                    (lambda (x) (error 'object "nothing here")))])
          
          ; Reassocia self com o lambda seletor dos métodos
          (begin 
            (set! self
              (lambda (msg)
                (case msg
                  ; O macro cria, um lambda usando o nome do
                  ; método, a variável do lambda e o corpo.
                  ; Como pode haver vários métodos, estamos 
                  ; fazendo de forma recursiva
                  [(mtd-name) (lambda (var) val)]
                  ...)))
          self)
      ) ;end let
]))

; O resultado do código expandido seria:
(let ([self 'dummy])
  (begin 
    (set! self
      (λ (msg)
        (case msg
          [(first  (λ (x) (msg self)) )]
          [(second (λ (x) (+ x 1))    )]
)))))

Para contornarmos esse problema, poderíamos passar o 'self' como
argumento para a macro. Dessa maneira, o símbolo ao ser usado dentro
do contexto do uso da macro, quando ela for setada.

; Por que esse self não dá problemas quando passado como argumento?
(define os-2
    (object/self-2 self ; O nome do próprio argumento deve ser passado
                        ; como primeiro parâmetro.
        [first  (x) (msg self 'second (+ x 1))]
        [second (x) (+ x 1)]
))

(define-syntax object/self-2
  (syntax-rules ()
    [(object self [mtd-name (var) val] ...)
        
      ; Primeiro, associamos self com um símbolo qualquer. 
      ; No caso, é um lambda que imprime que está vazio.
      (let ([self (lambda (msg-name)
                    (lambda (x) (error 'object "nothing here")))])
          
          ; Reassocia self com o lambda seletor dos métodos. Agora,
          ; este é o self externo, e estamos afetando a tabela dos 
          ; argumentos.
          (begin 
            (set! self
              (lambda (msg)
                (case msg
                  [(mtd-name) (lambda (var) val)]
                  ...)))
          self)
      ) ;end let
]))

Mas nem sempre seria desejável passar 'self' como argumento. Como evitar
isso? Poderíamos usar um recurso adicional, suportado pelo Racket, que
permite associar um símbolo DENTRO DA SINTAXE com um DE FORA DA SINTAXE.
Dessa maneira, uma mudança de estado dentro da macro altera o espaço das 
variáveis passadas como argumento para a macro. Assim, conseguiríamos
sobrescrever o self (o que não acontecia na 1ª forma, pois o self estava
em outra tabela de símbolos).

(define os-3
    (object/self-3
        [first  (x) (msg self 'second (+ x 1))]
        [second (x) (+ x 1)]
))

(define-syntax object/self-3
  (syntax-case ()
    [(object [mtd-name (var) val] ...)
      (with-syntax ([self (datum->syntax x 'self)])
        #'(let ([self (lambda (msg-name)
                        (lambda (x) (error 'object "nothing here")))])
            (begin 
              (set! self
                (lambda (msg-name)
                  (case msg-name
                    [(mtd-name) (lambda (var) val)]
                    ...
              )))
              self
            )
          ) ; let
      ) ; with-syntax
    ] ; definição de objeto
))


17.02-Client Server
ESTRUTURA CLIENTE SERVIDOR
============================

(define (read-number [prompt : string]) : number
    (begin
        (display prompt)             ; Mostra o prompt
        (let ([v (read)])            ; Lê da stdin e associa a v
            (if (s-exp-number? v)    ; Testa se é número
                (s-exp->number v)    ; Converte para número
                (read-number prompt) ; Se não funcionar, lê outro
                                     ; número
))))

(display 
    (+ (read-number "Fist number")
       (read-number "Second number"))
)

Se estivéssemos numa arquitetura cliente-servidor, este programa simples
de somar NÃO FUNCIONARIA. Você pediria o programa, o servidor enviaria a
pergunta "First number" e, então, acabaria a conexão.

CLIENTE-SERVIDOR COM MEMÓRIA
------------------------------

Precisamos quebrar o programa em DUAS PARTES: o primeiro pedido do
número (requisição 1), e depois executar o pedido do segundo número
(requisição 2). Até termos o segundo número, precisamos GUARDAR o 
primeiro deles.

Uma função que quebrasse poderia ser:

(lambda (v1)
  (display
    (+ v1
      (read-number "Second number")
)))

Guardamos v1 no environment do lambda e depois esperamos pelo segundo
número aparecer.

CLIENTE-SERVIDOR SEM MEMÓRIA
------------------------------

Mas essa solução usa memória. Se tivéssemos vários usuários, poderíamos
ter muitos dados armazenados. No pior caso, isso se tornaria um ataque
DDoS (Denial of Service), pois exauriríamos o recurso do servidor.

Uma boa solução para contornarmos isso será criar uma ação que se
interrompe, enquanto aguarda pelas respostas dos usuários. Para cada
solicitação teremos um id único. Enviamos para o usuário um formulário
que contém o id da ação a ser realizada. Quando ele enviar os dados, o 
servidor executará a ação.

; Como usaremos o hacket na maior parte de seus recursos, usaremos 
; a feature de criar um HASH para manter a tabela de símbolos de 
; ID_REQUISIÇÃO → PROGRAMA

; O label para os processos serão números. 
; A tabela será um hash vazio.
(define-type-alias label number)
(define table (make-hash empty))

; A função read-number/suspend apenas pega uma ação "rest" e a
; carrega na tabela de requisições.
(define (read-number/suspend [prompt : string] rest)
  
  ; New label é uma simples função contadora
  (let ([g (new-label)])
    (begin
      (hash-set! table g rest)
      (display prompt)
      (display " To enter it, use the action field label ")
      (display g)
)))

; Esta ação é a "resposta", que envia o dado solicitado para o servidor.
; Na analogia web, esta seria uma página com FORMULÁRIO, a ser submetido
; ao servidor. Na resposta, teríamos o ACTION-FIELD, o label do hash que
; marca ONDE ESTÁ A AÇÃO A SER EXECUTADA.
(define (resume [f : label] [n : number])
  ((sum-v (hash-ref table g)) n)
)

; A ação usando o read-number com suspensão fica:
(read-number/suspend 
  "First number"
  (lambda (v1)
     (display
       (+ v1
         (read-number "Second number"))))
)

; Para um esquema cliente-servidor mais robusto (no caso, que lesse os 
; dois números via este sistema), precisaíamos usar duas solicitações.

A representação das solicitações ficaria:

            Servidor             |              Cliente
=================================|====================================
                                 |            
   . read-number/interrupt  -----:----- label: 05
   :                             |      form: Mande valor
   :                             |            
   :   table                     |      resume 05 42
   : .----.--------------.       |           |
   : |    |              |       |           |
   : |    |              |       |           |
   : |    |              |       |           |
   : |    |              |       |           |
   '>| 05 | rest         | <-----:-----------'
     |    |  |           |       |            
     |    |  |           |       |            
     '----'--|-----------'       |            
             ^                   |
         read-number             |

ESQUEMA CLIENTE-SERVIDOR COMPLETO
-----------------------------------

Há um problema: o lambda solicitando o v2 pede no servidor (o que não
é realista). Para resolver, basta colocarmos uma solicitação dentro da
outra:

(read-number/suspend 
  "First number"
  (lambda (v1)
    (read-number/suspend 
      "Second number"
        (lambda (v2)
          (display
            (+ v1 v2)
)))))

            Servidor             |              Cliente
=================================|====================================
                                 |            
 ..- read-number/interrupt  -----:----- label: 05
 : .-'                 ^    |    |      form: Mande valor
 : :                   |    |    |            
 : :   table           |    |    |      resume 05 42
 : : .----.------------|-.  |    |           |
 : : |    |            | |  |    |           |
 : : |    |  sum       | |  '----:-----------:------ resume 03 0
 : : |    |   ^        | |       |           |            |
 : '>| 03 | rest2      | | <-----:-----------:------------'
 :   |    |            | |       |           |
 '-->| 05 | rest1 -----' | <-----:-----------'
     |    |              |       |            
     |    |              |       |            
     '----'--------------'       |            
                                 |

18.01-Client Server
ARQUITETURA CLIENTE-SERVIDOR
==============================

Em geral, as formas que colocamos na arquitetura da última aula mantém o
ESTADO salvo dentro do hash dos labels. Porém, essa é uma forma, muitas
vezes, pouco eficiente: um usuário pode demorar para responder, ou pode
recarregar uma página web, resolicitar, etc.

Duas soluções, que mantém o estado fora do servidor, são possíveis:
* Manter o estado na aplicação
    Usando variáveis escondidas, que não aparecem numa página web, é
    possível enviar dados e/ou ações pela rede. Este protocolo é SEM 
    ESTADO: o protocolo não muda de acordo com o que está sendo
    transferido. Ele apenas transfere informação de um ponto a outro.
    O estado está nas aplicações (ações feitas), não no protocolo. 
    Nesse caso, não temos uma tabela que armazena dados/ações. O que
    precisa ser feito é enviado dentro do protocolo.

* Manter o estado no cliente
    Usamos o conceito de "cookies". Arquivos disponíveis no navegador 
    do usuário e que um dado site pode editar. Ele o usa para guardar 
    as informações dentro do cliente, no momento em que submete um
    formulário para o servidor. O servidor pode, então, usar estes dados
    SALVOS no cliente para continuar as ações.
    
    ; cookies
    (define cookie '-100)
    
    (define (read-number/suspend "\nFirst number (cookie)"
      (lambda (v1)
        (begin
          (set! cookie v1)
          (read-number/suspend "\nSecond number (cookie)"
                               (lambda (v2) (display (+ cookie v2)))
      )))
    ))

    Este é um exemplo de transimissão de informações chamado
    continuation passing style (CPS). Ele consiste, primariamente, de
    quebrar uma ação numa sequência de passos. Dado um passo i, ele 
    executa a computação correspondente a ele e depois envia o restante
    da operação i+1 para ser executada depois.

18.02-continuation passing style
CONTINUATION PASSING STYLE
============================

Este método de computação é o utilizado dentro do esquema
cliente-servidor (mesmo com suas várias formas de manter o estado). O
conceito chave é quebrar uma certa computação em uma série de passos
menores, em que vamos mantendo o "resto" da computação depois da
operação.

Ex:
    ; Toda expressão CONSTANTE deve ser quebrada na forma:
    ; * Constantes cte:
    ; (λ (resto) (resto cte) )
    
    - Original:
    (+ 2 2)
    
    - CPS:
    (
        (λ (resto) (resto 2))
        (λ (x) (+ x 2))
    )

Ex:
    ; Todo LAMBDA deve ser quebrada na forma:
    ; * Lambdas (λ (arg) (ação arg)):
    ; (λ (arg resto) (resto (ação arg)) )
    
    - Original:
    ((λ (a) (+ (* a 2) 5)) 2)
    
    - CPS:
    (
        ; Criamos um lambda com a computação mais interna, (* a 2)
        ; que é depois aplicada no "resto" da ação.
        (λ (a, resto) (resto (* a 2)))
        
        ; O argumento para este lambda são dois valores: o x e o resto.
        (2 (λ (x) (+ x 5)))
    )

Para cada tipo de estrutura, quebraríamos de forma diferentes. Essa é
uma forma de TRANSFORMAÇÃO, em que estamos modificando o programa SEM
alterar o resultado. A implementação poderia ser feita de duas formas:
* Açúcar : Usando macros para transformar as sentenças originais;
* Core   : Modificar o core para implementar esta forma.

Se pegássemos uma expressão, teríamos a transformação na forma:
e:    3 * (5 + 2) - 7 * 4
f(x): 3 * x - 7 * 4         e = f(5+2)
g(y): y - 7 * 4             e = g(f(5+2))
...                         ...

Estamos passando o resultado de uma ação para a próxima. Essa é a ideia
de PILHA DE EXECUÇÃO, como feita em Assembly. Cada ação devolve apenas
uma modificação de estado, e o estado é compartilhada pelas várias ações
necessárias para serem feitas.

19.01-macros for cps
MACROS PARA CPS
=================

Vamos criar um processador de macros para o estilo de processamento de
continuação. Com ele, transformaremos um tipo de expressão em outra.

Fazeremos uma conversão de sintaxe. Escreveremos com nosso estilo, e a
traduziremos com os comandos tradicionais do Racket para o estilo de 
continuação.
    
              |  Sintaxe CPS  |    Racket    |
              |===============|==============|
              | with          | let          |
              | rec           | letrec       |
              | lam           | lambda       |
              | cnd           | if           |
              | set           | set!         |
              | seq           | begin        |

(define-syntax (cps e)
  (syntax-case e (with rec lam cnd seq set quote display read-number)
    
    [(_ atomic)
        #'(lambda (k) (k atomic))]
    
    ; Rec é como o let recursivo (letrec), que muda o storage
    ; conforme novas associações são feitas
    [(_ (rec (v f) b))
        #'(cps (with (v (lam (arg) (error 'dummy "nothind")))
                  (seq
                    (set v f)
                    b)))
    ]
    
    ; lambda
    [(_ (lam (a) b))
      (identifier? #'a)
      
      ; Toda sintaxe convertida deve ser um lambda que recebe como
      ; parâmetro uma continuação. Essa continuação, definida no 
      ; tempo de definição da função, chama-se k. O corpo da função,
      ; seja qual for, deve ser argumento para esta continuação.
      #'(lambda (k)
          
          ; Todo argumento devolvido por uma função também deve 
          ; estar no CPS. Precisamos converter o λ de verdade para
          ; esse estilo. Para fazer isso:
          ; 1) Expandimos a lista de argumento para receber como 
          ;    argumento final uma continuação: dyn-k
          ; 2) O corpo também precisa ser passado para o estilo de
          ;    continuação. Isso pode ser feito aplicando a 
          ;    continuação dyn-k para ele.
          ;
          (k (lambda (a dyn-k) ((cps b) dyn-k) ))
    ]
    
    ; Ex:
    ; (λ (a) b)
    ; (λ (k) 
    ;    (k (λ (a dyn-k) (eps b dyn-k)))
    ; )
    ; 
    ; Ex:
    ; (cps (+ (rn "um") (rn "dois")) )
    ; ( 
    ;     (λ (k) 
    ;        (+ k (rn "dois"))
    ;     )
    ;     (rn "um") 
    ; )
    
    [(_ (f a))
        #'(lambda (k)
           ((cps f) (lambda (fv)
               ((cps a) (lambda (av) (fv av k)))
          )))
    
    [(_ (f a b))
        ; Pegamos uma aplicação de função, com dois argumentos.
        ; Ela tem uma continuação
        #'(lambda (k)
           ; Interpretamos 'a' e passamos como continuação para 
           ; ele o segundo argumento
           ((cps a) (lambda (av)
               ; Interpretamos 'b' e passamos como continuação para
               ; ele a funçaõ aplicada a ambos os argumentos
               ((cps b) (lambda (bv)
                    (k (f av bv) )))))
          )
    ]
))

; Continuação "identidade", para não fazermos nada na última continuação
(define identity '(lambda (c) c))

; Açúcar sintático para rodar expressões feitas na linguagem
; de escrita de continuações. Ele pega uma continuação e passa
; como continuação final para ela a identidade, que fará a última
; ação parar a recursão.
(define (run [k : s-exp]) (k identity) )

Exemplo de expansão
---------------------

(cps (display (+ (rn "f") (rn "s"))) )

(λ (k) ( (cps (+ (...) (λ (ov (k (display ov))))))
         (λ(k) ( (λ (k2) ((cps (rn ...) 
                            (λ (av) (cps ((rn "s"))
                              (λ (bv) (k2 (f av bv))))))))))


20.01-cps
Continuation Passing Style
============================

Umexemplo simples de CPS possível seriafazer a soma passo a passo:
(+ a b)

(λ (k) ((cps a) (λ (av) ((cps b) (λ (bv) (k (+ av bv)))))))
        ^^^^^^^    ^^^^  ^^^^^^^    ^^^^    ^^^^^^^^^
          (1)       (2)    (3)       (4)       (5)

1) Primeiro, calculamos o argumento 'a' da soma. O resultado será um
   lambda que aceita uma continuação;
2) O valor calculado em 'a' será passado para a continuação - e salvo
   no labmda com a associação de do da computação com av;
3) A continuação comeva calculando o argumento 'b' da soma. O resultado
   será um lambda que aceita uma continuação;
4) O valor calculado em 'b' será passado para a continuação - e salvo
   na lambda com a associação do resultado da computação com bv;
5) Usando 'av' e 'bv', realizamos a última computação (somar av com
   bv, o primeiro salvo no environment desse lambda). O resultado deve
   ser aplicado na continuação global da expressão: k.

Se quiséssemos apenas EXECUTAR, então poderíamos executar esta
continuação passando 'k' como a função identidade.


20.02-cps in the core
CPS MONTADO NO CORE
=====================

Como poderíamos fazer para alterar a nossa última linguagem, de modo a
criar CPS? Simples: a partir da árvore, vamos interpretá-la construindo
estruturas em CPS. Precisaremos passar, a cada uma das interpretações,
qual é a CONTINUAÇÃO.

(define-type Value
    [numV  (n : number)]
    
    ; Nosso valor é uma função:
    ; 1. Que tem como domínio um valor com dois argumentos:
    ;    1.1 Um valor
    ;    1.2 Uma função de Valor em Valor
    ; 2. Que tem como imagem um valor
    ;
    [closV (f : (Value (Value -> Value) -> Value))]
    ;           |(1.1)      (1.2)           (2)  |
    ;           |                                |
    ;           '-------------- (1) -------------'
)

(define (interp/k [expr : ExprC] [env : Env] [k : (Value -> Value)]) Value
  (type-case ExprC expr
    [numC (n)   (k (numV n))]
    [idC (n)    (k (lookup n env))]
    
    ; Precisamos:
    ; 1. Calcular o valor de f (intepretar a expressão f). Passamos
    ;    o environment corrente + uma continuação.
    ; 2. Armazenar o resultado de f, guardando esse valor num λ
    ; 3. Calcular o valor de a (interpretar a expressão a). Passamos
    ;    o environment corrente + uma continuação.
    ; 4. Guardamos o valor interpretado de a em f
    ; 5. Por último, aplicamos a closure, passando:
    ;    5.1. av como argumento principal
    ;    5.2. k como continuação, para computar o restante
    [appC (f a) (interp/k f env (lambda (fv)
                                  (interp/k a env
                                    (lambda (av) (closV-f fv) av k)
                                )))
    ]
    
    ; Não precisamos passar uma continuação com num+. Como ele não faz
    ; mais nada - ele é um caso básico - não precisamos passar o k para 
    ; lá. Numa função qualquer, que poderia ter mais chamadas de
    ; funções, precisaríamos PASSAR esta continuação porque a função
    ; vai para o outro lugar.
    [plusC (l r) (interp/k l env (lambda (lv) 
                   (interp/k r env (lambda (rv) 
                     (k (num+ lv rv))
                   ))
                 ))
    ]
    
    ; Análogo ao caso acima
    [multC (l r) (interp/k l env (lambda (lv) 
                   (interp/k r env (lambda (rv) 
                     (k (num* lv rv))
                   ))
                 ))
    ]
    
    ; Análogo aos casos acima
    [ifC (c y n) (interp/k c env (lambda (cv)
                   (if (zero? (numV-n cv))
                     (interp/k n env (lambda (nv) (k nv)))
                     (interp/k y env (lambda (yv) (k yv)))
                 )))
    ]
    
    ; No lambda, o processo segue os mesmos princípios:
    ; 1. Nosso valor de retorno será um closV, que recebe como 
    ;    argumento uma função de Valor em Valor
    ; 2. A função criada terá dois argumentos: um valor de argumento
    ;    (o argumento tradicional) e uma nova continuação (dyn-k). 
    ;    NÃO usamos k, pois ele é uma continuação na construção de
    ;    expressões. Caso nossa interpretação final tivesse como 
    ;    valor de retorno apenas um lambda, por exemplo, teríamos
    ;    um lamda que está no estilo CPS.
    ; 3. O corpo do lambda será a conversão para o estilo CPS
    ;    (interpretação) do argumento 'b'. Ele deverá ter como
    ;    environment o environment EXTENDIDO com a associação de 
    ;    'a' a 'arg-val'. Essa interpretação, porém, deverá ocorrer
    ;    sobre a continuação dyn-k.
    [lamC (a b) (k (closV (lambda (arg-val dyn-k)
                            (interp/k b
                              (extend-env (bind a arg-val) env) dyn-k))
    ))]
))

O interpretador muda pouco:
(define (interp [e : ExprC]) : ExprC
  (interp/k e mt-env identity))

Sendo a função identidade a base da recursão, que não faz nada:
(define (identity [i : ExprC] i))


21.01-generators
GERADORES
===========

Geradores são lambdas que interrompem sua execução, e, ao serem chamadas
novamente, continuam do ponto em que tinham parado.

Em orientação a objetos, temos um método que realiza uma ação como a de
um gerador: o iterador - que retorna o próximo elemento de algum tipo de
ação.

Em Python, existe suporte para geradores: o comando 'yield'

>>> def f() :
...    n = 0
...    while n >= 0 :
...        yield n
...        n += 3
>>> g = f()
>>> g.next()
0
>>> g.next()
3
>>> g.next()
6
>>> g.next()
9

Existes várias opções para implementar geradores:
1) Usando orientação a objetos (como via interfaces, em Java)
2) Usar uma fábrica de geradores, que funciona para qualquer lambda
3) Usar CPS (Continuation Passing Style) para a implementação

Nossa implementação usará:
- CPS (Continuation Passing Style)
- Retomada direta (sem o 'next')
- yield é um procedimento
- erro no final da execução

Para fazermos um Generator, teremos:

    .----------------------------------------------------------.
    |                          GENERATOR                       |
    |------------------------------.---------------------------|
    |     Entrada (chamada)        |       Saída (yield)       |
    |------------------------------|---------------------------|
    | Lembrar ONDE está quem chama | Saber para ONDE retornar  |
    |------------------------------X---------------------------|
    | Saber ONDE deve prosseguir   | Lembrar ONDE parou        |
    '------------------------------'---------------------------'

A nossas continuações está nos "ONDE" de todas as entradas e saídas:
saber o que virá em seguida é nossa continuação.

Quando entramos em um generator, salvamos a continuação da ação que
chamou o generator. Quando chegamos no yield, precisamos salvar o 
ponto do código em que estamos (para continuar na próxima chamada) 
e retornamos para a continuação de quem chamou a função. Na próxima
chamada, começaremos pelo Generator.

    ; O _ representa o nome o gerador de macros (cps)
    ; 
    ; Essa estrutura estará dentro do cps
    ; Toda vez que encontrarmos 'generator', teremos 3 argumentos
    ; 1. Função 'yield' que fará a interrupção
    ; 2. Valor para o generator (será apenas 1, por simplicidade)
    ; 3. Corpo da função com ações a serem realizadas
    ;
    [(_ (generator (yield) v b))
        
        ; Predicado: teste para ver se a conversão é válida
        (and (identifier? #'yield) (identifier? $'v))
        
        ; CPS transformado: nossa continuação com algo a mais
        #'(lambda (k) (k 
            ; Aqui está o nosso gerador: usaremos um let recursivo
            ; para podermos chamar as várias funções
            (letrec (
                [where-to-go 
                    ; A função where-to-go só é um auxiliar inicial,
                    ; para que apresentemos uma mensagem de erro no
                    ; caso de não termos nenhum yield no começo
                    (lambda (v) (error 'where-to-go "nothing"))
                ]
                [resumer
                    ; A função resumer é a responsável por executar
                    ; o corpo do generator. Como ele está em CPS, 
                    ; quando terminarmos de executá-lo deveremos 
                    ; "sair" da função com uma exceção.
                    ;
                    ; Esta definição de resumer será sobrescrita 
                    ; ao chamarmos um yield dentro do corpo. Porém,
                    ; a execução inicial do corpo, em cps, com a 
                    ; continuação sendo o erro, já está feita.
                    ;
                    (lambda (v) (
                        (cps b) (lambda (k)
                        (error 'generator "fell though"))
                    ))
                ]
                [yield
                    ; Nossa função yield deve ser chamada de dentro
                    ; do corpo da função. Ela está em CPS, e por isso
                    ; tem um argumento e uma continuação (gen-k). 
                    ; 
                    ; Como resumer está salva dentro do ambiente do
                    ; letrec, podemos sobrescrevê-lo usando o set.
                    ; O novo resumer será a continuação do generator.
                    ; 
                    ; Quando chamarmos o lambda na segunda execução,
                    ; 'resumer' fará com que a nossa função comece 
                    ; em gen-k: justamente o que queríamos - o 
                    ; programa partir da continuação.
                    ; 
                    (lambda (v gen-k) (begin
                        (set! resumer gen-k)
                        (where-to-go v)
                    ))
                ]
            
            ); fim do letrec
                
                ; Quando executamos nossa função, setamos qual será
                ; a continuação ao acabarmos esta rodada do lambda.
                ; Uma vez feito isso, executamos 'resumer'
                (λ (v dyn-k) (begin
                    (set! where-to-go dyn-k)
                    (resumer v)
                ))
            )
        ))
    ]

Resumindo o passo-a-passo da construção do generator:
1. Nosso generator é um lambda em CPS. Deverá ter um argumento (v) e 
   uma continuação (dyn-k). Ele salva o dyn-k no storage e aplica
   a função resumer com argumento 'v'.

2. A primeira versão de resumer é simples: chama o corpo 'b' que 
   (definido na implementação generator) com o valor 'v'. Como 
   'b' está em CPS, ele precisa de continuação. Conforme nossa 
   definição inicial, ao acabar de executar devolveremos uma 
   exceção (que nada mais é que um lambda).

3. Dentro do corpo, pode haver chamadas de 'yield'. O 'yield' 
   é um lambda em CPS que recebe um argumento e uma continuação.
   A continuação é o trecho de código que, em Python, vem logo 
   após o 'yield'. Como as funções 'where-to-go', 'yield' e 
   'resumer' estão salvas dentro do mesmo letrec, podemos alterar
   o storage associado a esses símbolos. Por isso, 'yield' 
   sobrescreve 'resumer' para ser esta continuação.

4. Daí para frente, a execução continua, nesse processo de substituição
   de 'resumer' por 'yield' e execução das continuações.


22.01-types
TIPOS
======

De forma geral, quando temos expressões, não temos como saber se o
resultado será válido ou não. Em alguns casos, teremos erro certamente.
Em outros, sempre funcionará. No terceiro caso, não teremos como saber
até o tempo de execução.

Por esse motivo, existem os tipos. Eles permitem que verifiquemos a 
validade de algumas expressões ainda antes da execução. Por exemplo:
* [XX] (+ 3 (λ (x) x)) 
  Sempre será errada, porque não conseguimos somar função e número.
* [OK] (let ([f (λ (x) (+ x 1))]) (+ 3 (f 5)) )
  Teremos necessariamente um número retornado na aplicação de f,
  e o programa funcionará.
* [XX] (let ([f (λ (x) (λ (y) (+ x y)))]) (+ 3 (f 5)) )
  F devolverá sempre uma função, e não funcionará.
* [??] (λ (f) (+ 3 (f 5)))
  O resultado só poderia ser visto em tempo de execução, pois
  depende do argumento f.
* [??] (+ 3 (zero? (read-number) 5 (λ (x) x)) )
  Nesse caso, não teríamos nenhuma maneira de verificar o tipo
  até que ocorresse a execução.

Cada linguagem lida com esses diversos problemas de formas diferentes.
Algumas, como o Racket padrão, Python ou Perl não verificam de forma
alguma. Uma opção é verificar tipos em tempo de execução, o que causaria
um overhead muito grande. De outras maneiras, poderíamos ter problemas.

Tipo
|--> Conjunto dos valores
'--> Qualquer propriedade verificável sem a necessidade de executar
     o programa.

* Essa definição de tipos mostra que nem sempre é possível verificá-los.
  Caso conseguíssemos testá-los em todos os casos, estaríamos resolvendo 
  o problema da parada de Turing (que é indecidível, o que nos mostra
  que nem sempre é possível).
* Expressões estão associadas a tipos que devem ser consistentes.

* Desvantagens da tipagem
    - Perda de flexibilidades (aumenta as restrições)
    - Pode aumentar o custo computacional
    - Exige anotação do programa
    - Problema de computabilidade
* Possíveis vantagens
    - Evita tempo de depuração (diminui erros de execução)
    - Captura erros em trechos não executados
    - Documentação (os tipos, por si próprios, conseguem mostrar
      o que uma função recebe e retorna)
    - Auxilia o compilador (permite otimizações voltadas 
      a um dado tipo)
    - Força um código mais elegante (padronizado)

SISTEMA DE TIPOS
==================

Existem três elementos essenciais para implementar um sistema de tipos:
1) Coleção de tipos
2) Um julgamento: valor ↔ tipo ? (sistema formal)
3) Um algoritmo para o julgamento

* Cada expressão tem uma regra:
    { n         : número
    { (λ (a) b) : função
    Essas associações são mantidas num ENVIRONMENT DE TIPOS (Γ)

* Julgador
    Γ  ⊢  n         : Número
    Γ  ⊢  (λ (a) b) : Função
    Partindo dos axiomas em nossa teoria (Γ), conseguimos provar por
    meio de regras de dedução que algo pertence a um tipo.

* Faremos as representações usando a seguinte forma:
    procedentes
    -----------  Numa forma parecida com o método de prova da 
    conclusões   dedução natural
    
    Usaremos a seguinte notação:
    * Γ         : ambiente de tipos (associações)
    * Γ ⊢       : julgador
    * τx        : tipo de x
    * Γ[x ← τ1] : ambiente estendido
    * ∅         : ambiente vazio
    
    Γ ⊢ l : num  Γ ⊢ r : num  
    ------------------------  Regra de dedução natural para a SOMA
       Γ ⊢ (+ l r) : num      
    
    Γ ⊢ f : func  Γ ⊢ a : τa } Agora, não temos como deduzir o tipo
    ------------------------ } de retorno apenas sabendo que f é do
        Γ ⊢ (f a) : ?        } tipo função
    
    Γ ⊢ f : τa → τb  Γ ⊢ a : τa  } Regra de dedução natural para a 
    ---------------------------  } APLICAÇÂO DE FUNÇÃO
           Γ ⊢ (f a) : τb        } Na função, precisamos da notação
                                       domínio → contradomínio
    
    Γ[a ← τ1] ⊢ b : τ2 } Regra de dedução natural para a DEFINIÇÃO
    ------------------ } DE FUNÇÃO
    Γ ⊢ (λ (a) b) : τ2 } Nossa teoria estendida, com a hipótese de que
                         a é do tipo τ1, prova que b é do tipo τ2. 
                         Nesse caso, o lambda retorna τ2.
    
    Γ ⊢  c : boolean  Γ ⊢ y : τ1  Γ ⊢ n : τ2 } Se tivermos argumentos
    ---------------------------------------- } de tipos diferentes no 
              Γ ⊢ (if c y n) : ?             } if não teríamos como 
                                               diferenciar para a 
                                               dedução
    
    Γ ⊢  c : boolean  Γ ⊢ y : τ1  Γ ⊢ n : τ1 } Regra de dedução natural
    ---------------------------------------- } para o IF
               Γ ⊢ (if c y n) : τ1           } 

* Exemplos:
    - (+ 2 (+ 5 7)) 
      ; Soma simples (funciona)
    
        ∅ ⊢ 2 : num  ∅ ⊢ 5 : num  ∅ ⊢ 7 : num
                     ------------------------
                        ∅ ⊢ (+ 5 7) : num
        -------------------------------------
              ∅ ⊢ (+ 2 (+ 5 7)) : num
    
    - (+ 3 (λ ([x : num] : num x))) 
      ; Soma com função (não funciona)
    
        ∅ ⊢ 3 : num   (λ ([x : num] : num x)) : num → num
        --------------------------------------------------
                ∅ ⊬ (+ 3 (λ ([x : num] : num x)))
        
        Não está definido uma regra de soma de num → num
    
    - Laço infinito com combinador-Y
      
      (                    (                    (
        (λ (x) (x x))  →     (λ (x) (x x))  →     (λ (x) (x x))  →  ...
        (λ (x) (x x))  →     (λ (x) (x x))  →     (λ (x) (x x))  →  ...
      )                    )                    )
      ^^^^^^^^^^^^^^^      ^^^^^^^^^^^^^^^      ^^^^^^^^^^^^^^^
        1ª Iteração          2ª Iteração          3ª Iteração
    
      ω : τa → τω      } Para descrevermos essa recursão infinita
             τa → τρ   } (pelo uso do combinador-Y), precisaríamos
                   ... } de uma dedução infinitamente longa.
      
      Caso essa lista fosse finita, seria possível provar que o 
      programa para. Mas se o programa sempre parar, então resolvemos
      o Problema da Parada. Isso é impossível, pois o problema é 
      indecidível. Então essa linguagem que usamos NÃO É CAPAZ de 
      descrever esse laço infinito.
      
      Para suportarmos a existência de recursão, precisaremos criar
      uma regra que use lazyness:
      
      Γ[i ← τi] ⊢ b : τ  Γ[i ← τi] ⊢ v : τi
      -------------------------------------
           Γ ⊢ (rec (i : τi v) b) : τ
      
      O "rec" é o lambda que faz a construção de recursão - seja via
      combinador-y ou por manutenção do estado. Ele precisa de dois
      argumentos: o primeiro, uma lista que contenha o SÌMBOLO A 
      SER USADO PARA A CHAMADA RECURSIVA (i) com A FUNÇÃO USADA PARA
      GERAR A RECURSÃO (v); o segundo, o CORPO DA FUNÇÃO (b).
      
      O argumento "i" precisa ser do mesmo tipo do v, porque 
      será associado a ele dentro da implementação recursiva. 
      Também, usando a associação de 'i' com seu tipo, precisamos
      provar que o corpo retornará τ.
      
* Podemos resumir as regras como sendo:
    
    .===============.==========================================.
    |   OPERAÇÂO    | REGRA                                    |
    |===============|==========================================|
    |  +,-,*,/      | Γ ⊢ l : num  Γ ⊢ r : num                 |
    |               | ------------------------                 |
    |               |    Γ ⊢ (+ l r) : num                     |
    |===============|==========================================|
    | (λ (a) b)     | Γ[a ← τ1] ⊢ b : τ2                       |
    |               | ------------------                       |
    |               | Γ ⊢ (λ (a) b) : τ2                       |
    |===============|==========================================|
    | (f a)         | Γ ⊢ f : τa → τb  Γ ⊢ a : τa              |
    |               | ---------------------------              |
    |               |        Γ ⊢ (f a) : τb                    |
    |===============|==========================================|
    | (if c y n)    | Γ ⊢  c : boolean  Γ ⊢ y : τ1  Γ ⊢ n : τ1 |
    |               | ---------------------------------------- |
    |               |            Γ ⊢ (if c y n) : τ1           |
    |===============|==========================================|
    | (rec (i v) b) | Γ[i ← τi] ⊢ b : τ  Γ[i ← τi] ⊢ v : τi    |
    |               | -------------------------------------    |
    |               |     Γ ⊢ (rec (i : τi v) b) : τ           |
    '==============='=========================================='
